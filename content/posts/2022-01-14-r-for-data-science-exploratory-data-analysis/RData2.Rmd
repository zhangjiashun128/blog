---
title: R for Data Science:Exploratory Data Analysis
author: Zhang Jiashun
date: '2022-01-14'
slug: []
categories:
  - R
tags:
  - R
  - Data
description: ~
featured_image: ~
---
EDA is an interative cycle

```{r}
library(tidyverse)
library(patchwork)
library(modelr)
```

## Questions

You can loosely word these questions as:
1. What type of variation occurs within my variables?
2. What type of covariation occurs between my variale?

## Variation
- categorical

```{r}
ggplot(data = diamonds) +
  geom_bar(mapping = aes(x = cut))
```
You can compute these values manually with `dplyr::count()`:

```{r}
diamonds %>% 
  count(cut)
```

- continuous

```{r}
ggplot(data = diamonds) +
  geom_histogram(mapping = aes(x = carat), binwidth = 0.5)
```
You can compute this by hand by combining `dplyr::count()` and `ggplot2::cut_width()`:

```{r}
diamonds %>% 
  count(cut_width(carat, 0.5))
```
You can set the width of the intervals in a histogram with the `binwidth` argument:

```{r}
smaller <- diamonds %>% 
  filter(carat < 3)
ggplot(data = smaller, mapping = aes(x = carat)) +
  geom_histogram(binwidth = 0.1)
```
If you wish to overlay multiple histograms in the same plot,  using `geom_freqpoly()` instead of `geom_histogram()` is better:

```{r}
ggplot(data = smaller, mapping = aes(x = carat, colour = cut)) +
  geom_freqpoly(binwidth = 0.1)
```
### Typical values

```{r}
ggplot(data = smaller, mapping = aes(x = carat)) +
  geom_histogram(binwidth = 0.01)
```

```{r}
ggplot(data = faithful, mapping = aes(x = eruptions)) +
  geom_histogram(binwidth = 0.25)
```

### Unusual values

```{r}
ggplot(diamonds) +
  geom_histogram(mapping = aes(x = y), binwidth = 0.5)
```

To make it easy to see the unusual values, we need to zoom to small values of the y-axis with `coord_cartesian()`:

```{r}
ggplot(diamonds) +
  geom_histogram(mapping = aes(x = y), binwidth = 0.5) +
  coord_cartesian(ylim = c(0, 50))
```

(`coord_cartesian()` also has an `xlim()` argument for when you need to zoom into the x-axis. ggplot2 also has `xlim()` and `ylim()` functions that work slightly differently: they throw away the data outside the limits.)

```{r}
unusual <- diamonds %>% 
  filter(y < 3 | y > 20) %>% 
  select(price, x, y, z) %>% 
  arrange(y)
unusual
```
## Missing values

If you’ve encountered unusual values in your dataset, and simply want to move on to the rest of your analysis, you have two options.

1. Drop the entire row with the strange values:

```{r}
diamonds2 <- diamonds %>% 
  filter(between(y , 3, 20))
```

2. Instead, I recommend replacing the unusual values with missing values.The easiest way to do this is to use `mutate()` to replace the variable with a modified copy. You can use the `ifelse()` function to replace unusual values with `NA`:

```{r}
diamonds3 <- diamonds %>% 
  mutate(y = ifelse(y < 3 | y > 20, NA, y))
diamonds3
```
`ifelse()` has three arguments. The first argument test should be a logical vector. The result will contain the value of the second argument, yes, when test is TRUE, and the value of the third argument, no, when it is false. Alternatively to ifelse, use dplyr::case_when(). case_when() is particularly useful inside mutate when you want to create a new variable that relies on a complex combination of existing variables.

ggplot2 doesn’t include missing values in the plot, but it does warn that they’ve been removed:

```{r}
ggplot(data = diamonds3, mapping = aes(x = x, y = y)) +
  geom_point()
```
To suppress that warning, set `na.rm = TRUE`:

```{r}
ggplot(data = diamonds2, mapping = aes(x = x, y = y)) + 
  geom_point(na.rm = TRUE)
```

Other times you want to understand what makes observations with missing values different to observations with recorded values. For example, in `nycflights13::flights`, missing values in the `dep_time` variable indicate that the flight was cancelled. So you might want to compare the scheduled departure times for cancelled and non-cancelled times. You can do this by making a new variable with `is.na()`.

```{r}
nycflights13::flights %>% 
  mutate(
    cancelled = is.na(dep_time),
    sched_hour = sched_dep_time %/% 100,
    sched_min = sched_dep_time %% 100,
    sched_dep_time = sched_hour + sched_min / 60
  ) %>% 
  ggplot(mapping = aes(sched_dep_time)) +
  geom_freqpoly(mapping = aes(colour = cancelled), binwidth = 1/4)
```

- In the `geom_histogram()` function,missing values are removed when the number of observations in each bin are calculated. See the warning
message: Removed 9 rows containing non-finite values (stat_bin)

- In the `geom_bar()` function, NA is treated as another category. The x aesthetic in `geom_bar()`requires a
discrete (categorical) variable, and missing values act like another category.

## Covariation

 The best way to spot covariation is to visualise the relationship between two or more variables. How you do that should again depend on the type of variables involved.
 
### A categorical and continuous variable

```{r}
ggplot(data = diamonds, mapping = aes(x = price)) +
  geom_freqpoly(mapping = aes(colour = cut), binwidth = 500)
```

```{r}
ggplot(diamonds) +
  geom_bar(mapping = aes(x = cut))
```

To make the comparison easier we need to swap what is displayed on the y-axis. Instead of displaying count, we’ll display **density**, which is the count standardised so that the area under each frequency polygon is one.

```{r}
ggplot(data = diamonds, mapping = aes(x = price, y = ..density..)) +
  geom_freqpoly(mapping = aes(colour = cut), binwidth = 500)
```

Another alternative to display the distribution of a continuous variable broken down by a categorical variable is the boxplot.

A **boxplot** is a type of visual shorthand for a distribution of values that is popular among statisticians. Each boxplot consists of:
- A box that stretches from the 25th percentile of the distribution to the 75th percentile, a distance known as the interquartile range (IQR). In the middle of the box is a line that displays the median, i.e. 50th percentile, of the distribution. These three lines give you a sense of the spread of the distribution and whether or not the distribution is symmetric about the median or skewed to one side.

- Visual points that display observations that fall more than 1.5 times the IQR from either edge of the box. These outlying points are unusual so are plotted individually.

- A line (or whisker) that extends from each end of the box and goes to the farthest non-outlier point in the distribution.

```{r}
ggplot(data = diamonds, mapping = aes(x = cut, y = price)) +
  geom_boxplot()
```

```{r}
ggplot(data = mpg, mapping = aes(x = class, y = hwy)) +
  geom_boxplot()
```
To make the trend easier to see, we can reorder `class` based on the median value of `hwy`:

```{r}
ggplot(data = mpg) +
  geom_boxplot(mapping = aes(x = reorder(class, hwy, FUN = median), y = hwy))
```

If you have long variable names, `geom_boxplot()` will work better if you flip it 90°. You can do that with `coord_flip()`.

```{r}
ggplot(data = mpg) +
  geom_boxplot(mapping = aes(x = reorder(class, hwy, FUN = median), y = hwy)) +
  coord_flip()
```

### Two categorical variable

To visualise the covariation between categorical variables, you’ll need to count the number of observations for each combination. One way to do that is to rely on the built-in `geom_count()`:

```{r}
ggplot(data = diamonds) +
  geom_count(mapping = aes(x = cut, y = color))
```

Another approach is to compute the count with dplyr:

```{r}
diamonds %>% 
  count(color, cut)
```
Then visualise with geom_tile() and the fill aesthetic:

```{r}
diamonds %>% 
  count(color, cut) %>% 
  ggplot(mapping = aes(x = color, y = cut)) +
  geom_tile(mapping = aes(fill = n))
```

## Two continuous variables

```{r}
ggplot(data = diamonds) +
  geom_point(mapping = aes(x = carat, y = price))
```
Scatterplots become less useful as the size of your dataset grows, because points begin to overplot, and pile up into areas of uniform black (as above).One way to fix the problem: using the `alpha` aesthetic to add transparency.

```{r}
ggplot(data = diamonds) +
  geom_point(mapping = aes(x = carat, y =price), alpha = 1 / 100)
```

But using transparency can be challenging for very large datasets. Another solution is to use bin. Previously you used `geom_histogram()` and `geom_freqpoly()` to bin in one dimension. Now you’ll learn how to use `geom_bin2d()` and `geom_hex()` to bin in two dimensions.

`geom_bin2d()` and `geom_hex()` divide the coordinate plane into 2d bins and then use a fill color to display how many points fall into each bin. `geom_bin2d()` creates rectangular bins. `geom_hex()` creates hexagonal bins. You will need to install the hexbin package to use `geom_hex()`.

```{r}
p1 <- ggplot(data = smaller) +
  geom_bin2d(mapping = aes(x = carat, y = price))

p2 <- ggplot(data = smaller) +
  geom_hex(mapping = aes(x = carat, y = price))
p1 + p2
```
Another option is to bin one continuous variable so it acts like a categorical variable. Then you can use one of the techniques for visualising the combination of a categorical and a continuous variable.

```{r}
ggplot(data = smaller, mapping = aes(x = carat, y =price)) +
  geom_boxplot(mapping = aes(group = cut_width(carat, 0.1)))
```
 By default, boxplots look roughly the same (apart from number of outliers) regardless of how many observations there are, so it’s difficult to tell that each boxplot summarises a different number of points. One way to show that is to make the width of the boxplot proportional to the number of points with `varwidth = TRUE`.

```{r}
ggplot(data = smaller, mapping = aes(x = carat, y = price)) + 
  geom_boxplot(mapping = aes(group = cut_width(carat, 0.1)), varwidth = T)
```

Another approach is to display approximately the same number of points in each bin. That’s the job of `cut_number()`:

```{r}
ggplot(data = smaller, mapping = aes(x = carat, y = price)) + 
  geom_boxplot(mapping = aes(group = cut_number(carat, 20)))
```
## Patterns and models

```{r}
ggplot(data = faithful) + 
  geom_point(mapping = aes(x = eruptions, y = waiting))
```
```{r}
mod <- lm(log(price) ~ log(carat), data = diamonds)

diamonds4 <- diamonds %>% 
  add_residuals(mod) %>% 
  mutate(resid = exp(resid))

ggplot(data = diamonds4) +
  geom_point(mapping = aes(x = carat, y =resid))

```

```{r}
ggplot(data = diamonds4) +
  geom_boxplot(mapping = aes(x = cut, y = resid))
```

